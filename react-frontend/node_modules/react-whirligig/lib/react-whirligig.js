(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('react-dom')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', 'react-dom'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['react-whirligig'] = {}, global.React, global.ReactDOM));
}(this, (function (exports, React, reactDom) { 'use strict';

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var Slide = function Slide(_ref) {
    var _ref$basis = _ref.basis,
        basis = _ref$basis === void 0 ? '100%' : _ref$basis,
        _ref$gutter = _ref.gutter,
        gutter = _ref$gutter === void 0 ? '1em' : _ref$gutter,
        _ref$className = _ref.className,
        className = _ref$className === void 0 ? '' : _ref$className,
        children = _ref.children,
        props = _objectWithoutProperties(_ref, ["basis", "gutter", "className", "children"]);

    return /*#__PURE__*/React.createElement("div", _extends({
      className: className,
      style: {
        flex: '0 0 auto',
        width: basis,
        marginLeft: gutter
      }
    }, props), children);
  };

  var includes = function includes(val, arr) {
    return arr.includes ? arr.includes(val) : !!arr.filter(function (item) {
      return item === val;
    }).length;
  };

  var wrapAroundValue = function wrapAroundValue(val, max) {
    return (val % max + max) % max;
  };

  var hardBoundedValue = function hardBoundedValue(val, max) {
    return Math.max(0, Math.min(max, val));
  };

  var normalizeIndex = function normalizeIndex(idx, len) {
    var wrap = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    return wrap ? wrapAroundValue(idx, len) : hardBoundedValue(idx, len - 1);
  };
  var values = Object.values || function (obj) {
    return Object.keys(obj).map(function (key) {
      return obj[key];
    });
  };
  var noop = function noop() {};
  var easeOutQuint = function easeOutQuint(t) {
    var n = t;
    return 1 + --n * Math.pow(n, 4);
  };
  var on = function on(evt) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return function (cb) {
      return function (el) {
        if (el && typeof el.addEventListener === 'function') {
          el.addEventListener(evt, cb, opts);
          return function () {
            return el.removeEventListener(evt, cb);
          };
        }
      };
    };
  };
  var onWindowScroll = function onWindowScroll(cb) {
    return on('scroll', true)(cb)(window);
  };
  var onScroll = function onScroll(cb) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$target = _ref.target,
        target = _ref$target === void 0 ? window : _ref$target;

    return onWindowScroll(function (e) {
      return (target === window || target === e.target) && cb(e);
    });
  };
  var onScrollEnd = function onScrollEnd(cb) {
    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref2$wait = _ref2.wait,
        wait = _ref2$wait === void 0 ? 100 : _ref2$wait,
        _ref2$target = _ref2.target,
        target = _ref2$target === void 0 ? window : _ref2$target;

    return function (timeoutID) {
      return onScroll(function (evt) {
        clearTimeout(timeoutID);
        timeoutID = setTimeout(function () {
          return evt.target === target ? cb() : undefined;
        }, wait);
      });
    }(0);
  };
  var onScrollStart = function onScrollStart(cb) {
    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref3$target = _ref3.target,
        target = _ref3$target === void 0 ? window : _ref3$target;

    var started = false;
    var offScrollEnd = onScrollEnd(function () {
      started = false;
    }, {
      target: target
    });
    var offScroll = onScroll(function (e) {
      if (!started) {
        started = true;
        cb(e);
      }
    }, {
      target: target
    });
    return function () {
      if (typeof offScroll === 'function') {
        offScroll();
      }

      if (typeof offScrollEnd === 'function') {
        offScrollEnd();
      }
    };
  };
  var onSwipe = function onSwipe(cb) {
    return function (target) {
      var offTouchStart = on('touchstart')(function (_ref4) {
        var targetTouches = _ref4.targetTouches;
        var _targetTouches$ = targetTouches[0],
            startX = _targetTouches$.pageX,
            startY = _targetTouches$.pageY;
        var offTouchEnd = on('touchend')(function (_ref5) {
          var changedTouches = _ref5.changedTouches;
          var _changedTouches$ = changedTouches[0],
              endX = _changedTouches$.pageX,
              endY = _changedTouches$.pageY;
          var xDiff = endX - startX;
          var absXDiff = Math.abs(xDiff);
          var yDiff = endY - startY;
          var absYDiff = Math.abs(yDiff);

          if (Math.max(absXDiff, absYDiff) > 20) {
            var dir = absXDiff > absYDiff ?
            /* h */
            xDiff < 0 ? 'right' : 'left' :
            /* v */
            yDiff < 0 ? 'down' : 'up';
            cb(dir);
          }

          if (typeof offTouchEnd === 'function') {
            offTouchEnd();
          }
        })(target);
      })(target);
      return offTouchStart;
    };
  };
  var trackTouchesForElement = function trackTouchesForElement(el) {
    var touchIds = [];
    on('touchend')(function (_ref6) {
      var targetTouches = _ref6.targetTouches;
      touchIds = targetTouches;
    })(el);
    return function () {
      return touchIds.length;
    };
  };
  var trackOngoingMouseInteraction = function trackOngoingMouseInteraction(el) {
    var isInteracting = false;
    on('mousedown')(function () {
      isInteracting = true;
    })(el);
    on('mouseup')(function () {
      isInteracting = false;
    })(document.body);
    return function () {
      return isInteracting;
    };
  };
  var hasOngoingInteraction = function hasOngoingInteraction(el) {
    var getOngoingTouchCount = trackTouchesForElement(el);
    var getOngoingMouseClick = trackOngoingMouseInteraction(el);
    return function () {
      return !!getOngoingTouchCount() || getOngoingMouseClick();
    };
  };
  var fakeChild = {
    getBoundingClientRect: function getBoundingClientRect() {
      return {};
    }
  };
  var isWhollyInView = function isWhollyInView(parent) {
    return function () {
      var child = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : fakeChild;

      var _child$getBoundingCli = child.getBoundingClientRect(),
          cLeft = _child$getBoundingCli.left,
          cRight = _child$getBoundingCli.right;

      var _parent$getBoundingCl = parent.getBoundingClientRect(),
          pLeft = _parent$getBoundingCl.left,
          pRight = _parent$getBoundingCl.right;

      return cLeft >= pLeft && cRight <= pRight;
    };
  };

  var supportsPassive = function supportsPassive() {
    try {
      window.addEventListener('__rw_test__', null, {
        passive: true
      });
      window.removeEventListener('__rw_test__', null);
      return true;
    } catch (_unused) {
      return false;
    }
  };

  var animate = function animate(el) {
    var _ref7 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref7$delta = _ref7.delta,
        delta = _ref7$delta === void 0 ? 0 : _ref7$delta,
        _ref7$immediate = _ref7.immediate,
        immediate = _ref7$immediate === void 0 ? false : _ref7$immediate,
        _ref7$duration = _ref7.duration,
        duration = _ref7$duration === void 0 ? 500 : _ref7$duration,
        _ref7$easing = _ref7.easing,
        easing = _ref7$easing === void 0 ? easeOutQuint : _ref7$easing,
        _ref7$prop = _ref7.prop,
        prop = _ref7$prop === void 0 ? 'scrollTop' : _ref7$prop;

    return new Promise(function (res, rej) {
      if (!delta) {
        return res();
      }

      var initialVal = el[prop];

      if (immediate) {
        el[prop] = initialVal + delta;
        return res();
      }

      var hasBailed = false;

      var bail = function bail() {
        hasBailed = true;
        var pos = el[prop];
        el.removeEventListener('touchstart', bail);
        el[prop] = pos;
        return rej('Animation interrupted by interaction');
      };

      el.addEventListener('touchstart', bail, supportsPassive() ? {
        passive: true
      } : false);
      var startTime = null;

      var step = function step(timestamp) {
        if (hasBailed) {
          return;
        }

        if (!startTime) {
          startTime = timestamp;
        }

        var progressTime = timestamp - startTime;
        var progressRatio = easing(progressTime / duration);
        el[prop] = initialVal + delta * progressRatio;

        if (progressTime < duration) {
          window.requestAnimationFrame(step);
        } else {
          el[prop] = initialVal + delta; // jump to end when animation is complete. necessary at least for immediate scroll

          res();
        }
      };

      window.requestAnimationFrame(step);
    });
  };

  var Whirligig = /*#__PURE__*/function (_React$Component) {
    _inherits(Whirligig, _React$Component);

    var _super = _createSuper(Whirligig);

    function Whirligig(props) {
      var _this;

      _classCallCheck(this, Whirligig);

      _this = _super.call(this, props);

      _defineProperty(_assertThisInitialized(_this), "eventListeners", []);

      _defineProperty(_assertThisInitialized(_this), "isScrolling", false);

      _defineProperty(_assertThisInitialized(_this), "canSelfCorrect", function () {
        return !_this.props.preventAutoCorrect && !_this.state.isAnimating && !_this.isScrolling && !_this.isInteracting();
      });

      _defineProperty(_assertThisInitialized(_this), "shouldSelfCorrect", function () {
        return _this.props.snapToSlide && _this.canSelfCorrect();
      });

      _defineProperty(_assertThisInitialized(_this), "handleKeyUp", function (nextKeys, prevKeys) {
        return function (_ref) {
          var key = _ref.key;
          var isNext = includes(key, nextKeys);
          var isPrev = includes(key, prevKeys);

          _this.setState({
            isAnimating: true
          });

          if (isNext) {
            _this.next().catch(noop);
          }

          if (isPrev) {
            _this.prev().catch(noop);
          }

          return false;
        };
      }(_this.props.nextKeys, _this.props.prevKeys));

      _defineProperty(_assertThisInitialized(_this), "getPartiallyObscuredSlides", function () {
        var _assertThisInitialize = _assertThisInitialized(_this),
            whirligig = _assertThisInitialize.whirligig;

        var findFirstObscuredChildIndex = _toConsumableArray(whirligig.children).findIndex(function (child, i, children) {
          return !isWhollyInView(whirligig)(child) && isWhollyInView(whirligig)(children[i + 1]);
        });

        var firstObscuredChildIndex = Math.max(findFirstObscuredChildIndex, 0);

        var findLastObscuredChildIndex = _toConsumableArray(whirligig.children).findIndex(function (child, i, children) {
          return !isWhollyInView(whirligig)(child) && isWhollyInView(whirligig)(children[i - 1]);
        });

        var lastObscuredChildIndex = Math.max(findLastObscuredChildIndex, 0) || whirligig.children.length - 1;
        return [firstObscuredChildIndex, lastObscuredChildIndex];
      });

      _defineProperty(_assertThisInitialized(_this), "getNearestSlideIndex", function () {
        var _this$whirligig = _this.whirligig,
            children = _this$whirligig.children,
            scrollLeft = _this$whirligig.scrollLeft;
        var offsets = [].slice.call(children).map(function (_ref2) {
          var offsetLeft = _ref2.offsetLeft;
          return Math.abs(offsetLeft - scrollLeft);
        });
        return offsets.indexOf(Math.min.apply(Math, _toConsumableArray(offsets)));
      });

      _defineProperty(_assertThisInitialized(_this), "setWhirligigRef", function (r) {
        _this.whirligig = r;
      });

      _this.state = {
        activeIndex: props.startAt,
        isAnimating: false,
        visibleSlides: _this.props.visibleSlides || 0,
        slideBy: _this.props.slideBy || _this.props.visibleSlides || 0
      }; // We can't do arrow function properties for these since
      // we are passing them to the consuming component and we
      // require the proper context

      _this.next = _this.next.bind(_assertThisInitialized(_this));
      _this.prev = _this.prev.bind(_assertThisInitialized(_this));
      _this.slideTo = _this.slideTo.bind(_assertThisInitialized(_this));
      return _this;
    }

    _createClass(Whirligig, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this2 = this;

        this.DOMNode = reactDom.findDOMNode(this.whirligig);
        this.isInteracting = hasOngoingInteraction(this.DOMNode); // These are not a part of component state since we don't want
        // incure the overhead of calling setState. They are either cached
        // values or state only the onScrollEnd callback cares about and
        // are not important to the rendering of the component.

        this.childCount = this.whirligig && this.whirligig.children ? this.whirligig.children.length : 0;
        var slideBy = {
          left: function left() {
            return -_this2.state.slideBy;
          },
          right: function right() {
            return _this2.state.slideBy;
          },
          up: function up() {
            return 0;
          },
          down: function down() {
            return 0;
          }
        };
        this.eventListeners = [].concat(_toConsumableArray(this.eventListeners), [onScrollStart(function () {
          _this2.isScrolling = true;
        }), on('touchstart')(function () {
          _this2.isScrolling = true;
        })(this.whirligig), onScrollEnd(function () {
          _this2.isScrolling = false;

          if (_this2.canSelfCorrect()) {
            if (_this2.props.snapToSlide) {
              _this2.slideTo(_this2.getNearestSlideIndex()).catch(noop);
            } else {
              _this2.props.afterSlide(_this2.getNearestSlideIndex());
            }
          }
        }, {
          target: this.DOMNode
        }), on('touchend')(function () {
          if (_this2.canSelfCorrect()) {
            _this2.props.snapToSlide ? _this2.slideTo(_this2.getNearestSlideIndex()).catch(noop) : _this2.props.afterSlide(_this2.getNearestSlideIndex());
          }
        })(this.whirligig), onSwipe(function (direction) {
          if (!_this2.props.preventSwipe && _this2.props.snapToSlide) {
            _this2.slideTo(_this2.state.activeIndex + slideBy[direction]()).catch(noop);
          }
        })(this.whirligig)]);
        this.slideTo(this.props.startAt, {
          immediate: true
        }).catch(noop);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.eventListeners.forEach(function (fn) {
          return typeof fn === 'function' && fn();
        });
      } // eslint-disable-next-line camelcase

    }, {
      key: "UNSAFE_componentWillReceiveProps",
      value: function UNSAFE_componentWillReceiveProps(_ref3) {
        var slideBy = _ref3.slideBy,
            visibleSlides = _ref3.visibleSlides;

        if (slideBy !== this.props.slideBy || visibleSlides !== this.props.visibleSlides) {
          this.setState({
            slideBy: slideBy || visibleSlides || 1
          });
        }
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        this.childCount = this.whirligig && this.whirligig.children ? this.whirligig.children.length : 0;

        if (this.shouldSelfCorrect()) {
          var nearestSlideIndex = this.getNearestSlideIndex();
          nearestSlideIndex !== this.state.activeIndex && this.slideTo(this.getNearestSlideIndex()).catch(noop);
        }

        if (prevProps.slideTo !== this.props.slideTo) {
          this.slideTo(this.props.slideTo).catch(noop);
        }
      }
    }, {
      key: "shouldComponentUpdate",
      // isAnimating state is the only important state value to the rendering of this component
      value: function shouldComponentUpdate(nextProps, _ref4) {
        var isAnimating = _ref4.isAnimating;
        var propValues = [].concat(_toConsumableArray(values(this.props)), [this.state.isAnimating]);
        var nextPropValues = [].concat(_toConsumableArray(values(nextProps)), [isAnimating]);
        return !nextPropValues.every(function (val, i) {
          return val === propValues[i];
        });
      }
    }, {
      key: "next",
      value: function next() {
        var childCount = this.childCount,
            props = this.props,
            state = this.state;
        var activeIndex = state.activeIndex,
            slideBy = state.slideBy;
        var infinite = props.infinite;
        var firstIndex = 0;
        var lastIndex = childCount - slideBy;

        if (!slideBy) {
          var _this$getPartiallyObs = this.getPartiallyObscuredSlides(),
              _this$getPartiallyObs2 = _slicedToArray(_this$getPartiallyObs, 2),
              _ = _this$getPartiallyObs2[0],
              nextSlide = _this$getPartiallyObs2[1];

          var nextInfinteSlide = nextSlide === childCount - 1 ? 0 : nextSlide;
          return this.slideTo(infinite ? nextInfinteSlide : nextSlide);
        }

        var nextActiveCandidate = activeIndex + slideBy;
        var nextActive = Math.min(nextActiveCandidate, lastIndex);
        var nextActiveInfinite = activeIndex === lastIndex ? firstIndex : nextActive;
        return this.slideTo(infinite ? nextActiveInfinite : nextActive);
      }
    }, {
      key: "prev",
      value: function prev() {
        var childCount = this.childCount,
            state = this.state,
            props = this.props;
        var activeIndex = state.activeIndex,
            slideBy = state.slideBy;
        var infinite = props.infinite;
        var firstIndex = 0;
        var lastIndex = childCount - slideBy;

        if (!slideBy) {
          var prevSlide = Math.max(activeIndex - 1, firstIndex);
          var prevInfinteSlide = prevSlide === activeIndex ? childCount - 1 : prevSlide;
          return this.slideTo(infinite ? prevInfinteSlide : prevSlide);
        }

        var nextActive = Math.max(activeIndex - slideBy, firstIndex);
        var nextActiveInfinite = activeIndex === firstIndex ? lastIndex : nextActive;
        return this.slideTo(infinite ? nextActiveInfinite : nextActive);
      }
    }, {
      key: "slideTo",
      value: function slideTo(index) {
        var _this3 = this;

        var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            _ref5$immediate = _ref5.immediate,
            immediate = _ref5$immediate === void 0 ? false : _ref5$immediate;

        if (this.childCount === 0) {
          return Promise.reject('No children to slide to');
        }

        if (!this.whirligig) {
          return Promise.reject('The Whirligig is not mounted');
        }

        var _this$props = this.props,
            afterSlide = _this$props.afterSlide,
            beforeSlide = _this$props.beforeSlide,
            easing = _this$props.easing,
            duration = _this$props.animationDuration,
            infinite = _this$props.infinite,
            preventScroll = _this$props.preventScroll,
            snapPositionOffset = _this$props.snapPositionOffset;
        var _this$whirligig2 = this.whirligig,
            children = _this$whirligig2.children,
            scrollLeft = _this$whirligig2.scrollLeft;
        var slideIndex = normalizeIndex(index, this.childCount, infinite);
        var startingIndex = this.state.activeIndex;
        var delta = children[slideIndex].offsetLeft - scrollLeft - snapPositionOffset;

        if (startingIndex !== slideIndex) {
          beforeSlide(index);
        }

        this.setState({
          isAnimating: true,
          activeIndex: slideIndex
        });
        return new Promise(function (res, _) {
          if (immediate) {
            _this3.whirligig.scrollLeft = children[slideIndex].offsetLeft;
            return res();
          } else {
            var originalOverflowX = preventScroll ? 'hidden' : 'auto';
            var prop = 'scrollLeft';
            return res(animate(_this3.whirligig, {
              prop: prop,
              delta: delta,
              easing: easing,
              duration: duration,
              originalOverflowX: originalOverflowX
            }));
          }
        }).then(function () {
          _this3.setState({
            isAnimating: false
          });

          if (startingIndex !== slideIndex) {
            return afterSlide(slideIndex);
          }
        }).catch(function (_) {
          _this3.setState({
            isAnimating: false
          });
        });
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props2 = this.props,
            afterSlide = _this$props2.afterSlide,
            animationDuration = _this$props2.animationDuration,
            beforeSlide = _this$props2.beforeSlide,
            children = _this$props2.children,
            className = _this$props2.className,
            easing = _this$props2.easing,
            infinite = _this$props2.infinite,
            gutter = _this$props2.gutter,
            nextKeys = _this$props2.nextKeys,
            prevKeys = _this$props2.prevKeys,
            preventScroll = _this$props2.preventScroll,
            preventAutoCorrect = _this$props2.preventAutoCorrect,
            preventSwipe = _this$props2.preventSwipe,
            snapToSlide = _this$props2.snapToSlide,
            snapPositionOffset = _this$props2.snapPositionOffset,
            onSlideClick = _this$props2.onSlideClick,
            slideClass = _this$props2.slideClass,
            slideTo = _this$props2.slideTo,
            slideBy = _this$props2.slideBy,
            startAt = _this$props2.startAt,
            style = _this$props2.style,
            visibleSlides = _this$props2.visibleSlides,
            props = _objectWithoutProperties(_this$props2, ["afterSlide", "animationDuration", "beforeSlide", "children", "className", "easing", "infinite", "gutter", "nextKeys", "prevKeys", "preventScroll", "preventAutoCorrect", "preventSwipe", "snapToSlide", "snapPositionOffset", "onSlideClick", "slideClass", "slideTo", "slideBy", "startAt", "style", "visibleSlides"]);

        var preventScrolling = preventScroll ? 'hidden' : 'auto';
        var styles = {
          display: 'flex',
          flexFlow: 'row nowrap',
          justifyContent: 'space-between',
          overflowX: preventScrolling,
          msOverflowStyle: '-ms-autohiding-scrollbar',
          // chrome like scrollbar experience for IE/Edge
          position: 'relative',
          // makes .whirligig an offset parent
          transition: 'all .25s ease-in-quint',
          outline: 'none',
          WebkitOverflowScrolling: 'touch'
        };
        return /*#__PURE__*/React.createElement("div", _extends({
          className: className,
          style: _objectSpread2(_objectSpread2({}, style), styles),
          ref: this.setWhirligigRef,
          tabIndex: "0",
          onKeyUp: this.handleKeyUp,
          role: "list"
        }, props), React.Children.map(typeof children === 'function' ? children(this.next, this.prev) : children, function (child, i) {
          return /*#__PURE__*/React.createElement(Slide, {
            className: slideClass,
            key: "slide-".concat(i),
            basis: visibleSlides ? "calc((100% - (".concat(gutter, " * ").concat(visibleSlides - 1, ")) / ").concat(visibleSlides, ")") : 'auto',
            gutter: i > 0 ? gutter : '',
            onClick: onSlideClick,
            role: "listitem"
          }, child);
        }));
      }
    }]);

    return Whirligig;
  }(React.Component);

  _defineProperty(Whirligig, "defaultProps", {
    afterSlide: noop,
    animationDuration: 500,
    beforeSlide: noop,
    gutter: '1em',
    nextKeys: ['ArrowRight'],
    onSlideClick: noop,
    prevKeys: ['ArrowLeft'],
    preventAutoCorrect: false,
    preventScroll: false,
    preventSwipe: false,
    snapPositionOffset: 0,
    snapToSlide: false,
    startAt: 0,
    style: {}
  });

  exports.default = Whirligig;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
